---
title: "Introduction à R – 2e partie"
author: "Pascal Brissette"
date: '2022-03-23'
output:
  rmdformats::readthedown:
  self_contained: true
  lightbox: true
  highlight: tango
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile,
                    encoding = encoding,
                    output_dir = "~/Downloads")})
---

```{r parametres, include=FALSE, message=FALSE, warning=FALSE}
setwd("~/Downloads")
if(!"gutenbergr" %in% rownames(installed.packages())) {install.packages("gutenbergr")}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
extensions = c("ggplot2","rmdformats", "dplyr", "stringr", "gutenbergr")
lapply(extensions, require, character.only = TRUE)
```


## Objectifs de l'atelier

* Apprendre à manipuler des listes et des tableaux de données
* Se familiariser avec les structures de contrôle et les fonctions d'itération
* Apprendre à importer des textes depuis un dépôt en ligne

## Parties de l'atelier:

* Manipulation des listes et des tableaux de données
* Les structures de contrôle `if`, `for` et `while`
* Importation de textes du Projet Gutenberg avec l'extension GutenbergR

![](Atelier03IntroductionR.jpg)

## Structures de données: liste, matrice, tableau

### Rappel: le vecteur
Le vecteur est une structure à une seule dimension qui peut contenir un nombre quasi illimité d'éléments. Sa seule contrainte est de ne pouvoir accepter que des éléments du même type. Un vecteur doit être composé exclusivement de caractères, ou de nombres, ou de booléens (TRUE/FALSE).

Question de révision:

- Que se fera R si on essaye de concatéger un nombre entier et un nombre avec fractions? Un nombre avec fraction et une chaîne de caractères?
- Comment est-ce que je peux extraire le quatrième élément d'un vecteur?
- Comment est-ce que je peux remplacer un élément par un autre dans un vecteur?

### Manipulation des listes
La liste ressemble au vecteur en ceci qu'il s'agit d'une structure de données unidimensionnelle, dont la longueur pourra être obtenue avec la fonction `length()`, mais, contrairement au vecteur, elle peut contenir toutes sortes d'objets

On a appris à manipuler les vecteur dans le premier atelier, mais on a laissé de côté celle des listes. Recréons cette courte liste du premier atelier comprenant trois vecteurs ayant chacun trois éléments.

```{r}
mes_oeuvres_l <- list(auteurs = c("Mercier", "Stael", "Hugo", "Zola"),
                      oeuvres = c("Tableau de Paris", "Corinne", "Les Misérables", "La Débâcle"),
                     annees_pub = c(1781, 1807, 1862, 1892))

mes_oeuvres_l
```

Comme on a donné des noms à nos éléments, on peut utiliser l'opérateur `&` pour appeler le contenu de l'élément. L'élément ainsi extrait sera un vecteur et l'extraction de l'un de ses propres éléments se fait par indexation, nom ou booléen.

```{r extraction-liste-nom}
mes_oeuvres_l$auteurs

str(mes_oeuvres_l$auteurs)

mes_oeuvres_l$auteurs[2]

```

L'indexation d'une liste peut également se faire en utilisant la position de l'élément (double crochets).

```{r extraction-liste-position-booleen}
mes_oeuvres_l[[1]] # Extraction du premier élément de la liste

mes_oeuvres_l[[1]][2] # Extraction du deuxième élément du premier vecteur de la liste

```


Si je souhaite effectuer une opération sur chacun des éléments de la liste (pour autant que cela soit autorisé par le type de données qu'ils contiennent et par la fonction utilisée), je pourrais recourir à la fonction d'itération `lapply()`, qui prend au minimum deux arguments: `x`, soit une vecteur ou une liste sur lequel itérer, ainsi qu'une fonction qui sera appliquée à chaque membre de `x`. 

```{r}
lapply(mes_oeuvres_l, class) # Notez que la fonction, ici, n'est pas suivie des apostrophes. Les arguments de la fonction enchâssée dans `lapply` seront mis simplement les uns à la suite des autres après le nom de la fonction et séparés par des virgules.

lapply(mes_oeuvres_l, paste, "*",  sep = "")
```


### Manipulation des tableaux de données
Recréons un tableau de données à partir des éléments de la liste en mémoire.

```{r creation-data-frame}
(mes_oeuvres_df <- data.frame(mes_oeuvres_l))
```

On se souvient que chaque colonne d'un tableau de données constitue un vecteur indépendant des autres et composé de données d'un seul type. On peut cependant manipuler ces différents vecteurs et même produire de nouvelles colonnes à l'aide de ces manipulations. Ajoutons tout d'abord une colonne (variable) `prenom` au tableau puis assemblons, dans une nouvelle colonne, les éléments de cette colonne et ceux de la colonne auteurs. Et tant qu'à faire, profitons-en pour modifier le nom de cette colonne actuellement appelée `auteurs`.


```{r}
mes_oeuvres_df$prenom <- c("Louis-Sébastien", "Germaine de", "Victor", "Émile")

mes_oeuvres_df$nom_prenom <- paste(mes_oeuvres_df$auteurs, mes_oeuvres_df$prenom, sep = ", ")

mes_oeuvres_df <- mes_oeuvres_df[, c(5,1,4,2,3)]

names(mes_oeuvres_df)[names(mes_oeuvres_df)=="auteurs"] <- "nom"

```


Toutes ces opérations pourraient se faire à la chaîne à l'aide de l'extension `dplyr`, dont voici la feuille résumé
![](data-transformation (1)_Page_1.jpg)


Ajoutons une nouvelle colonne à notre tableau, réordonnons l'ordre des colonnes et donnons de nouveaux noms à toutes.

```{r}
mes_oeuvres_df <- mes_oeuvres_df %>%
  mutate(., abbreviation=paste(str_extract(prenom, pattern="[[:upper:]]"),
                               str_extract(nom, pattern="[[:upper:]]"), sep = " ")) %>%
  select(nom, prenom, abbreviation, oeuvres, annees_pub) %>% rename(., patronyme=nom)

```


## Les structures de contrôle
La fonction dont nous avons exploré l'anatomie dans le premier atelier est un outil très utile pour effectuer des opérations sur les données et structures de données. Mais la fonction ne  révèle vraiment sa souplesse et sa puissance qu'intégrée à des structures conditionnelles. On peut par exemple exiger d'une fonction qu'elle ne fasse ce pour quoi elle a été créée que si une condition particulière est remplie, ou qu'elle s'applique à chacune des 100 000 lignes d'un tableau, ou encore qu'elle cesse de s'appliquer dès qu'une  condition donnée est satisfaite. 

### L'instruction if()

Nous avons déjà croisé une telle syntaxe lorsqu'on souhaitait vérifier si certaines extensions étaient déjà installées dans nos dossiers R :

```{r condition-if}
if(!"ggplot2" %in% rownames(installed.packages())) {install.packages("ggplot2")}
```

La ligne de code ci-dessus doit se lire ainsi: « si la condition indiquée dans la parenthèse suivant `if` n'est pas vraie, exécute la commande incluse dans les accolades. » `installed.packages()` est une matrice dont les noms de lignes correspondent aux extensions installées dans vos dossiers. Ainsi, la ligne de code ci-dessus indique à R que si la extension `ggplot2` *n'est pas* incluse dans les noms de lignes de la matrice appelée par la fonction `installed.packages()`, il devra installer cette extension. 

L'instruction `if()` appelle donc la vérification d'une assertion contenue dans une parenthèse et, selon le résultat du test, elle exécutera ou non la ou les commandes qui suivent. On pourrait par exemple utiliser `if()` dans la création d'une nouvelle variable dans un tableau de données. Pour le montrer, créons pour commencer un tableau très simple, que l’on affiche à l’aide de la fonction `kable()` de l'extension `knitr`:


```{r}
auteures_quebecoises <- data.frame(nom = c("Anne Hébert",
                                           "Nicole Brossard",
                                           "Joséphine Bacon",
                                           "Martine Delvaux"),
                                   oeuvre = c("Le tombeau des rois",
                                              "Le désert mauve",
                                              "Un thé dans la toundra",
                                              "Les filles en série"),
                                   annee = c(1953L, 1993L, 2013L, 2016L),
                                   genre = c("poésie", "roman", "poésie", "essai"))
auteures_quebecoises
```

Nous pourrions demander à R d'imprimer une phrase si, dans mon tableau, on trouve une certaine valeur. 

```{r warning=FALSE}
if(1953L %in% auteures_quebecoises$annee) {print("Oui, le tableau comporte bien une oeuvre publiée en 1953.")} # VRAI
if("Kamouraska" %in% auteures_quebecoises$oeuvre) {print("Oui, Kamouraska fait bien partie des oeuvres du tableau.")} # FAUX
```

Les choses se déroulent bien comme nous l'avions prévu: la condition de la première ligne de code étant remplie (l'exécution du code renvoie `TRUE`), R exécute la commande contenue dans les accolades qui suivent. La condition de la deuxième ligne de code n'étant pas satisfaite, R n'exécute pas la commande qui suit.

Il serait bien entendu préférable de pouvoir ajouter une clause à notre test logique, et dire à R ce qu'il doit faire si la réponse au test est FALSE. On fait cela en utilisant l'instruction `else()`.

```{r warning=FALSE}
if("Kamouraska" %in% auteures_quebecoises$oeuvre) {print("Oui, Kamouraska fait bien partie des oeuvres du tableau.")
  } else {
    print("Non, Kamouraska ne fait pas partie des oeuvres du tableau.")
  }
```

Nous pourrions tirer parti de `if()` pour ajouter une auteure au tableau si, et seulement si cette auteure en est absente.

> Note: dans le code ci-dessous, on utilise la fonction `list()` plutôt que `c()`. Si vous avez fait le premier atelier, vous vous souviendrez qu'un vecteur ne peut contenir qu'un seul type de données, tandis qu'une liste peut contenir des données hétérogènes. Si vous essayez de concaténer dans un vecteur des données textuelles (de type `character()`) et des données numériques (de types `double()` ou `integer()`), R vous renverra une erreur.

```{r warning=FALSE}
if(!"Nelly Arcan" %in% auteures_quebecoises$nom) {
  auteures_quebecoises <- rbind(auteures_quebecoises, list("Nelly Arcan", "Putain", 2001L, "roman")) 
}
knitr::kable(auteures_quebecoises)
```

Et si cette auteure figure déjà dans le tableau, mais que nous souhaitions ajouter un autre de ses titres?

```{r}
if(!"Nelly Arcan" %in% auteures_quebecoises$nom) {             # Condition
  print("Non, Nelly Arcan ne figure pas dans le tableau.")      # Si condition remplie, exécute la commande
} else if (!"Folle" %in% auteures_quebecoises$oeuvre){         # Vérifie également si "Folle" figure dans les titres
  auteures_quebecoises <- rbind(auteures_quebecoises, list("Nelly Arcan", "Folle", 2004L, "roman"))     # Dans le cas contraire, ajoute-le
  print("Le roman Folle fait maintenant partie du tableau.")    # Puis (autre commande) imprime la chaîne de caractères suivante   
}
```

On souhaite parfois couvrir deux ou trois conditions sans pour autant anticiper sur tous les cas de figure. On peut alors terminer la série des `else if()` par un simple `else` qui indiquera ce qu'on souhaite faire de ces cas de figure qui ne répondent à aucune des conditions énumérées antérieurement.

Commençons par ordonner notre tableau en fonction des dates de publication avec `order()`, puis demandons à R d'ajouter une entrée au tableau pour la période antérieure à 1950 s'il n'existe pas déjà une entrée  pour cette période.

```{r}
# Ordonner le tableau en fonction de la date de publication des oeuvres
auteures_quebecoises <- auteures_quebecoises[order(auteures_quebecoises$annee),]

# La condition étant vraie, la commande indiquée dans la parenthèse de `if()` sera exécutée et créera une entrée pour la période antérieure à 1950.
if(auteures_quebecoises$annee[1] >= 1950) {
  auteures_quebecoises <- rbind(auteures_quebecoises, 
                                list("Elisabeth Bégon", "Lettres au cher fils", 1748L, "lettres"),
                                list("Blanche Lamontagne-Beauregard", "Visions gaspésiennes", 1913L, "poésie"),
                                list("Laure Conan", "Angéline de Monbrun", 1882L, "roman"))
} else {
  print("Le tableau comporte déjà une auteure et une oeuvres antérieures à 1950.")
}
knitr::kable(auteures_quebecoises <- auteures_quebecoises[order(auteures_quebecoises$annee),])
```

Si nous exécutons à nouveau la même structure conditionnelle, la déclaration de la parenthèse s'avèrera fausse, puisqu'une entrée vient d'être créée pour la période des origines à 1950. Dès lors, c'est la commande suivant l'instruction `else` qui le sera. 


```{r}
if(auteures_quebecoises$annee[1] >= 1950) {
  auteures_quebecoises <- rbind(auteures_quebecoises, 
                                list("Elisabeth Bégon", "Lettres au cher fils", 1748L, "lettres"),
                                list("Blanche Lamontagne-Beauregard", "Visions gaspésiennes", 1913L, "poésie"),
                                list("Laure Conan", "Angéline de Monbrun", 1882L, "roman"))
} else {
  print("Le tableau comporte déjà une auteure de la première moitié du XXe siècle.")
}
```


## Les boucles
Supposons maintenant que nous souhaitions ajouter à notre tableau une colonne dont les valeurs sont conditionnelles à celles contenues dans une ou plusieurs colonnes existantes. Une simple instruction `if` pourra-t-elle nous être utile? Essayons de créer une colonne *periode* fondée sur l'année de publication de chacune des oeuvres, et observons le résultat.


```{r warning=FALSE}
if(auteures_quebecoises$annee > 1999) {
  auteures_quebecoises$periode <- "XXIe siècle"
} else if(auteures_quebecoises$annee > 1899 & auteures_quebecoises$annee < 2000) {
  auteures_quebecoises$periode <- "XXe siècle"
} else if(auteures_quebecoises$annee >= 1799 & auteures_quebecoises$annee < 1900) {
  auteures_quebecoises$periode <- "XIXe siècle"
} else {
  auteures_quebecoises$periode <- "XVIIIe siècle"
}
knitr::kable(auteures_quebecoises)
```

Que s'est-il passé? Sans doute pas ce que nous espérions! R a vérifié la première assertion de la structure conditionnelle et a conclu qu'elle était fausse; il est donc passé à la suivante, et ainsi de suite jusqu'à ce qu'il trouve une assertion vraie ou une commande `else`. Il a dès lors appliqué au nouveau vecteur formant la colonne *periode* la même commande. Comme on le devine, cela n'est pas très utile. Ce qu'il faut, c'est que chaque observation ou ligne fasse l'objet d'une évaluation indépendante et que le résultat de la structure conditionnelle soit renvoyé comme valeur du nouveau vecteur *periode*. Il y a au moins deux manières de faire cela sans recourir à des extensions spécialisées dans la manipulation de données comme `dplyr`. La première consiste à utiliser une boucle de type `for`.

### Boucle `for`
La boucle `for` permet de répéter une opération un nombre de fois déterminé d'emblée. La structure de la boucle se présente comme suit: `for([nombre d'itérations]) {[commande(s)]}`.Si l'on connait d'avance le nombre de lignes d'un tableau et qu'on souhaite répéter une commande à chaque ligne, on peut fournir ce nombre dans la parenthèse et indiquer la commande entre les accolades. Cependant, le propre de la manipulation de données étant précisément la modification des jeux de données, on gagnera à laisser R compter lui-même le nombre de lignes (ou la longueur d'un vecteur, comme on le verra un peu plus loin) et indiquer le nombre d'itérations nécessaires pour passer à travers l'ensemble de la structure. On peut faire cela avec la fonction `nrow()`, que nous avons déjà vue. Utilisons cette fonction dans la parenthèse de la boucle, puis réinsérons notre instruction `if` composée ci-dessus. Les ajouts au code seront expliqués ci-dessous.

```{r ajout-auteures, warning=FALSE}
for(i in 1:nrow(auteures_quebecoises)) {
  if(auteures_quebecoises$annee[i] > 1999) {
  auteures_quebecoises$periode[i] <- "XXIe siècle"
  } else if(auteures_quebecoises$annee[i] > 1899 & auteures_quebecoises$annee < 2000) {
  auteures_quebecoises$periode[i] <- "XXe siècle"
  } else if(auteures_quebecoises$annee[i] >= 1799 & auteures_quebecoises$annee < 1900) {
  auteures_quebecoises$periode[i] <- "XIXe siècle"
  } else {
  auteures_quebecoises$periode[i] <- "XVIIIe siècle"
  }
}
knitr::kable(auteures_quebecoises)
```

Cette fois, notre instruction `if` a bel et bien été appliquée telle que nous le souhaitions. La parenthèse suivant `for` pourra paraitre absconse à première vue, mais sa composition est très simple. On donne d'abord à `for` un nom de variable quelconque. Par convention, on utilise la lettre *i* (largement utilisée dans les formules mathématiques pour indiquer la première dimension d'un objet). On aurait pu inscrire, en lieu et place, la chaine de caractères `chaque_ligne_du_tableau`; seulement, comme il faut réutiliser cette variable dans chacune des instructions du corps de la boucle, une telle chaine alourdirait la syntaxe. Nous indiquons donc à R que pour chaque ligne `i`, de la première jusqu'à la dernière — et on lui laisse le soin de trouver lui-même quelle ligne est la dernière du tableau —, nous souhaitons qu'il exécute les commandes insérées entre les accolades et formant le corps de la boucle. Nous lui indiquons ensuite, dans chacune des commandes de ce corps, l'élément précis sur lequel il doit appliquer la ou les fonctions. 

Nous savons que notre tableau comporte 8 observations. Nous le savons parce que nous pouvons l'embrasser d'un coup d'oeil (facile!) et parce que la grille de l'environnement globale nous l'indique. Cela veut dire que la commande de la parenthèse `1:nrow(auteures_quebecoises)` donnera, une fois la commande exécutée, une série de huit chiffres, de 1 à 8. C'est donc dire que, dans la première itération, la variable `i` sera égale à 1. Or nous avons déjà vu, dans l'atelier sur l'indexation des vecteurs et des listes par position, que si nous indiquons `[1]` à la suite du nom d'un vecteur ou d'une liste, R renverra le premier élément. Si nous indiquons plutôt `[2]` à la suite du nom du vecteur ou de la liste, R renverra le deuxième élément, et ainsi de suite. Essayons:

```{r}

i = 1
auteures_quebecoises$annee[i]
i = 2
auteures_quebecoises$annee[i]
# Etc.

```

Ce que nous fournissons à `for` dans la parenthèse qui suit immédiatement la commande, dans le bloc de code précédent, ce sont des précisions sur les éléments qui font l'objet de l'itération. Ce que nous lui fournissons ensuite, dans le corps de la boucle, ce sont les commandes à exécuter avec chaque élément `i` d'un vecteur ou d'une liste.

### Boucle `while`
Les boucles `while` ont la même structure que les boucles `for`, mais au lieu d'exécuter une commande un nombre de fois déterminé d'emblée, elles les exécutent tant et aussi longtemps qu'une certaine condition n'est pas remplie. Cette caractéristique les rend à la fois plus souples et plus dangereuses. Plus souple, parce qu'on n'est pas forcé de lui fournir un nombre prédéterminé d'itérations. Plus dangereuses, parce que si cette condition, pour quelque raison que ce soit, n'est pas remplie, la boucle se poursuit indéfiniment et il faudra y mettre un terme en utilisant un levier externe (fermeture forcée du logiciel, etc.). Ce type de structure a un intérêt particulier dans un programme interactif où une réponse donnée à une question peut entrainer l'exécution automatique d'une commande. Supposons par exemple qu'on souhaite inviter les internautes à ajouter des notices à notre tableau des auteures québécoises. On pourrait demander à nos internautes imaginaires de répondre à une série de questions correspondant aux valeurs du tableau, emmagasiner ces valeurs dans des vecteurs, les assembler dans une liste, puis joindre celle-ci à notre tableau. Les questions apparaitront dans la console lorsque vous exécuterez le code ci-dessous.

```{r ajout-interactif}
# Préparez-vous à ajouter des notices à notre tableau!
reponse <- tolower(readline(prompt = "Souhaites-tu ajouter une notice au tableau des auteures québécoises? (oui/non) "))
if(reponse == tolower("oui")) {
  while(!reponse == tolower("non")){     
  auteure_temp <- readline(prompt = "Écris le nom d'une auteure: ")
  oeuvre_temp <- readline(prompt = "Donne le titre de l'une de ses oeuvres: ")
  annee_temp <- readline(prompt = "Indique l'année de publication de cette oeuvre:  ")
  genre_temp <- readline(prompt = "Précise le genre de cette oeuvre:  ")
  periode_temp <- readline(prompt = "Fournis la période de cette oeuvre (exemple: 'XXIe siècle'):  ")
  une_notice <- list(auteure_temp, oeuvre_temp,
                     annee_temp, genre_temp,
                     periode_temp)   # les différentes réponses sont rassemblées dans une liste
  auteures_quebecoises <- rbind(auteures_quebecoises, une_notice)
  reponse <- tolower(readline(prompt = "Merci pour l'ajout de cette notice! Souhaites-tu en ajouter une autre? (oui/non) "))
}
} else {
  print("Merci tout de même d'avoir bien voulu répondre à cette question!")
}

auteures_quebecoises <- auteures_quebecoises[order(auteures_quebecoises$annee),]
knitr::kable(auteures_quebecoises)
```

On notera que, dans le code ci-dessus, les deux dernières commandes sont extérieures à la boucle, ce qui veut dire qu'elles ne sont exécutées qu'au terme des itérations, après la fermeture de la boucle.

## Les fonctions 'ifelse()' et 'lapply()'
Il y a parfois des manières plus simples d'itérer à travers les éléments d'un objet que d'utiliser une instruction `if` ou une boucle.

### ifelse()
La fonction de base ifelse est à la fois très simple et très pratique. Elle comporte trois arguments: 1) un test; 2) une commande à exécuter si le test est positif; 3) une commande à exécuter si le test est négatif. Dans l'exemple ci-dessous, nous allons créer une nouvelle colonne (`type`) à notre tableau en fonction des valeurs de la colonne `genre`. 

```{r}
for(i in 1 : nrow(auteures_quebecoises)){
  auteures_quebecoises$type[i] <- ifelse(test = auteures_quebecoises$genre[i] %in% c("lettres", "roman", "essai"),
                                         yes = "prose",
                                         no = "vers")
}

knitr::kable(auteures_quebecoises <- auteures_quebecoises[,c(1,2,3,5,4,6)]) # On réordonne ici les colonnes pour une présentation plus adéquate

# saveRDS(auteures_quebecoises, "donnees/auteures_quebecoises.RDS") # sauvegarde de cette table pour des ateliers ultérieurs
```


## Importation de gazouillis
Le temps est venu de manipuler de plus riches structures de données textuelles. Les Projet Gutenberg, dont les livres en libre accès peuvent être normalement importés grâce à l'extension gutenbergR, ne semble pas accessible actuellement. Tournons-nous donc vers Twitter pour observer les mots qui circulent dans la twittosphère!

Les gazouillis ont été moissonnés grâce à l'extension `rtweet`. 

```{r, include=FALSE}
library(dplyr)
library(jsonlite)
library(httr)
library(rtweet)
library(tidyverse)
library(tidytext)
library(lsa)
# Sys.setenv(BEARER_TOKEN = "AAAAAAAAAAAAAAAAAAAAAOt0TAEAAAAAQuJEFD1l6Le1Du%2FwzZpZ50qvD2I%3DEB6jdsMufkrvFegGV9fsMstpCxKjTa4ONWXg3qVxgdooaGIUHq")
# 
# consumer_key <- "nQnChcGVJ1BqySFaNa9iQblTO"
# consumer_secret <- "7HhZXuTC8MQh9kAtbkIo1pKQd2Ol0AYXqp2COTsjqTcFKG8408"
# access_token="281051869-9cJqNBYIYVhyvls73ZBvkfhIYGlL18QgxO5g78fJ"
# access_secret="xHPzQhxzZSqSCtC4ee7kn3IWTAZwXaKhfdv4Zurs542po"
# 
# setup_twitter_oauth(consumer_key, consumer_secret, access_token, access_secret)
# 
# litt_twitter <- search_tweets("#Litterature", n=18000, lang = "fr", include_rts = FALSE, type = "mixed")

# users_data(litt_twitter)
# 
# colnames(litt_twitter)
# 
# litt_twitter_reduit <- litt_twitter %>% select(created_at, screen_name, text, source, retweet_count,
#                                         reply_count, hashtags, media_type, place_name, place_type,
#                                         country, country_code, geo_coords, coords_coords, location,
#                                         description, followers_count, friends_count, account_created_at)
# 
# table(litt_twitter_reduit$country_code)


# 
# 
# 
# 
# litt_twitter_df <- twListToDF(litt_twitter)
# 
# litt_twitter_df <- tibble(litt_twitter_df)
# 
# tweet_words <- litt_twitter_df %>% select(id, text) %>% unnest_tokens(word, text)
# 
# tweet_words %>% filter(!word %in% c(lsa::stopwords_fr, "rt", "https", "t.co", "litterature","littérature", "c’est", "rép", "d'un", "qu'on", "o_franco_aleman", "roiphilippe75", "savez", "c'est")) %>% count(word, sort=T) %>% slice(1:30) %>% 
#   ggplot(aes(x = reorder(word,
#                          n), y = n)) +
#   geom_bar(stat = "identity") +
#   coord_flip() +
#   xlab(NULL)

```








