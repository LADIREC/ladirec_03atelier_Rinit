---
title: "Introduction à R – 2e partie"
author: "Pascal Brissette"
date: '2022-03-27'
output:
  rmdformats::readthedown:
  self_contained: true
  lightbox: true
  highlight: tango
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile,
                    encoding = encoding,
                    output_dir = "/cloud/project")})
---

```{r parametres, include=FALSE, message=FALSE, warning=FALSE}
setwd("/cloud/project")
if(!"gutenbergr" %in% rownames(installed.packages())) {install.packages("gutenbergr")}
if(!"trelliscopejs" %in% rownames(installed.packages())) {install.packages("trelliscopejs")}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
extensions = c("knitr", "ggplot2","rmdformats", "dplyr", "stringr", "gutenbergr", "reshape2",
               "plotly", "trelliscopejs")
lapply(extensions, require, character.only = TRUE)
rm(extensions)
```


## Parties de l'atelier

* Nature et manipulation des tableaux de données (`data.frame`)
* Importation de documents depuis le Projet Gutenberg
* Visualisation des valeurs d'un tableau à l'aide de graphiques

## Nature et manipulation des tableaux de données (`data.frame`)

### Rappel - le vecteur
Le vecteur est une structure à une seule dimension qui peut contenir un nombre théoriquement illimité d'éléments. Sa seule contrainte est de ne pouvoir accepter que des éléments du même type. Un vecteur doit être composé exclusivement de caractères, ou de nombres, ou de booléens (TRUE/FALSE).

Question de révision:

- Que fera R si on essaye de concaténer un nombre entier et un nombre avec fractions? Un nombre avec fraction et une chaîne de caractères?
- Comment peut-on extraire le quatrième élément d'un vecteur?
- Comment peut-on remplacer un élément par un autre dans un vecteur?
- Comment attribuer des noms aux éléments d'un vecteur?

### Qu'est-ce qu'un tableau de données
Le tableau de données, ou `data.frame` en R, est sans doute la structure la plus utilisée dans l'analyse des données. Il permet d'assembler en une seule table une série de vecteurs. Chaque colonne est ainsi composée d'un et d'un seul type de données, mais deux colonnes ou plus peuvent être de différents types. Le tableau de données partage avec la liste la capacité d'assembler des données hétérogènes, mais contrairement à la liste, le tableau de données les assemble en utilisant une deuxième dimension (les lignes ou observations).

Le tableau de données peut être créé avec la fonction `data.frame()`, auquel on fournit un nombre donné de vecteurs de même longueur.

```{r}
mes_oeuvres_df <- data.frame(nom = c("Anne Hébert",
                              "Nicole Brossard",
                              "Joséphine Bacon",
                              "Martine Delvaux"),
                      oeuvre = c("Le tombeau des rois",
                                 "Le désert mauve",
                                 "Un thé dans la toundra",
                                 "Les filles en série"),
                      annee = c(1953L, 1993L, 2013L, 2016L),
                      genre = c("poésie", "roman", "poésie", "essai"),
                      prose = c(FALSE, TRUE, FALSE, TRUE))

mes_oeuvres_df

```


### Comment indexer les valeurs du tableau de données?

#### L'indexation par position
L'indexation des valeurs du tableau de données peut se faire, comme dans le cas du vecteur, avec des crochets apposés au nom de l'objet. À la différence du vecteur, cependant, deux valeurs sont attendues pour cette opération, l'une pour les lignes ou observations, l'autre pour les colonnes ou variables. Par convention, on utilise la lettre `i` pour désigner la première valeur, et `j` pour désigner la seconde, selon le modèle `nom_du_tableau[i, j]`.

*À noter* Dans R, l'indexation commence à 1 et non à 0, comme dans plusieurs autres langages.

```{r}
mes_oeuvres_df[1,2] # Indexation d'une valeur unique; équivalent d'une cellule de la table.

mes_oeuvres_df[c(1:3),4] # Indexation de trois observations tirées de la variable en colonne 4.

mes_oeuvres_df[median(nrow(mes_oeuvres_df)), 1] # Indexation de la valeur de la première colonne correspondant à l'observation en position médiane du tableau.

mes_oeuvres_df[, ncol(mes_oeuvres_df)] # Extraction des valeurs de la dernière colonne du tableau
```

#### L'indexation par nom
Dans un tableau de données en R-base, chaque colonne et chaque ligne se voient attribuer un nom par défaut si cela n'a pas été fait manuellement. Créaons à nouveau le tableau de données initial sans attribuer de nom aux colonnes.

```{r}
mes_oeuvres_df <- data.frame(c("Anne Hébert",
                              "Nicole Brossard",
                              "Joséphine Bacon",
                              "Martine Delvaux"),
                      c("Le tombeau des rois",
                                 "Le désert mauve",
                                 "Un thé dans la toundra",
                                 "Les filles en série"),
                      c(1953L, 1993L, 2013L, 2016L),
                      c("poésie", "roman", "poésie", "essai"),
                      c(FALSE, TRUE, FALSE, TRUE))

mes_oeuvres_df
```

R composera par défaut des noms de colonnes en utilisant les valeurs du vecteur. Cela est assurément un problème, mais il est aisé de redéfinir ces noms par assignation.

```{r}

(colnames(mes_oeuvres_df) <- c("nom", "oeuvre", "annee", "genre", "prose"))

mes_oeuvres_df

```

Le même principe s'applique pour la création de noms de lignes.

```{r}
rownames(mes_oeuvres_df) # actuels noms de lignes

rownames(mes_oeuvres_df) <- paste(mes_oeuvres_df$annee, gsub("\\s", "_", mes_oeuvres_df$oeuvre), sep = "_")

mes_oeuvres_df
```


Il y a un grand avantage à avoir des noms de lignes. Ce sont des identifiants uniques qui seront par défaut exclus des calculs ou des opérations qui seront faites sur les valeurs des colonnes. Vous le verrez à l'usage.

L'indexation des observations et des variables peut se faire en utilisant les noms qui leur ont été donnés par défaut ou manuellement.

```{r indexation-tableu-nom}

mes_oeuvres_df["2013_Un_thé_dans_la_toundra",] # Indexation de la ligne "2"
mes_oeuvres_df[, "nom"] # Indexation de la colonne "nom"

mes_oeuvres_df["1993_Le_désert_mauve", "annee"] # indexation de la valeur `i`, `j` au croisement de la ligne "4" et de la colonne "annee"

```

L'opérateur `$` peut être utilisé comme raccourci pour l'indexation d'une colonne. On sait que chaque colonne constitue un vecteur et on pourra donc utiliser le crochet simple pour indexer la valeur spécifique qui nous intéresse au croisement de `i` et de `j`.

```{r indexation-tableau-position}

mes_oeuvres_df$oeuvre[2]

mes_oeuvres_df$nom[1:3]

mes_oeuvres_df$annee[c(1, 3:5)]

```

Et comme de fait, on peut se servir de ces différents modes d'indexation pour extraire ou remplacer une ou plusieurs valeurs

```{r indexation-tableau-operateur}

mes_oeuvres_df$oeuvre[1:2] <- c("Kamouraska", "L'écho bouge beau")
mes_oeuvres_df
```

Enfin, l'ajout d'une nouvelle colonne repose sur le même principe:

```{r ajout-colonne}
mes_oeuvres_df$initiales_auteur <- c("AH","NB", "JB", "MD")

mes_oeuvres_df <- mes_oeuvres_df[, c(1, 6, 2:5)] # Repositionnement de cette colonne dans le tableau

mes_oeuvres_df
```

## Comment importer des documents depuis le Projet Gutenberg?
Dans l'exercice qui suit, nous allons utiliser les notions vues antérieurement pour composer un tableau de données à partir de trois romans importés depuis le Projet Gutenberg.

Le Projet Gutenberg est un riche dépôt de textes numériques créé en 1971 par Michael Hart et constamment enrichi depuis. Il contient près de 41 000 documents relevant du domaine public aux États-Unis (95 ans). La plupart des documents offerts pour le téléchargement le sont en format txt ou epub. 

Ci-dessous, nous allons importer un premier tableau contenant les ouvrages en français du catalogue Gutenberg, puis nous allons filtrer ce tableau pour ne retenir que les ouvrages de l'auteure française Rachilde (1860-1953).

Les données importées dans R depuis le Projet Gutenberg se présentent sous la forme d'un tableau de type `tibble()`. Il s'agit d'un tableau de données qui possède toutes les caractéristiques d'un tableau de données de base (`data.frame`), mais qui a des avantages dont vous pourrez prendre connaissance en consultant l'extension `tibble`. Cette extension, comme `dplyr` et `stringr`, fait partie de la famille `tidyverse`.

```{r}
# On définit d'abord le site miroir de Projet Gutenberg depuis lequel nous allons importer les documents.
mon_miroir <- "http://mirrors.xmission.com/gutenberg/"

# La fonction `gutenberg_works()` de l'extention `gutenbergr` permet d'obtenir un tableau contenant les ouvrages disponibles.
ouvragesFrancais <- gutenberg_works(languages = "fr")

# Combien y a-t-il d'auteurs uniques de langue française dans le PG?
length(unique(ouvragesFrancais$author))

# On filtre les ouvrages français contenant, dans la colonne `author`, la chaîne de caractères "Rachilde", et on en extrait les identifiants uniques des romans de Rachilde offerts par le PG.
Rachilde_id <- ouvragesFrancais[grep(pattern = "Rachilde", x=ouvragesFrancais$author),1]

# On télécharge les ouvrages en question en demandant à obtenir une métadonnée supplémentaire.
RachildeLivres <- gutenberg_download(Rachilde_id$gutenberg_id, mirror = mon_miroir, meta_fields = "title")

str(RachildeLivres)

# Combien de lignes pour chaque roman?
table(RachildeLivres$title)

# Séparation des trois romans (Monsieur Vénus va demander une conversion de l'encodage, le document original ayant été encodé à la base en Latin1. Il faut demander sa conversion en UTF-8.)
monsieurVenus <- RachildeLivres[RachildeLivres$title == "Monsieur Vénus", 2]
monsieurVenus$text <- iconv(monsieurVenus$text, from = "Latin1", to="UTF-8")
demonAbsurde <- RachildeLivres[RachildeLivres$title == "Le Démon de l'Absurde", 2]
marquiseSade <- RachildeLivres[RachildeLivres$title == "La Marquise de Sade", 2]

# Assemblage des romans respectifs en trois vecteurs

demonAbsurde_v <- paste(demonAbsurde$text, collapse = " ")
monsieurVenus_v <- paste(monsieurVenus$text, collapse = " ")
marquiseSade_v <- paste(marquiseSade$text, collapse = " ")

# On combine les trois romans dans une table.
tableau_synthese <- data.frame(auteur = "Rachilde",
                               titre = c("Le Démon de l'Absurde", "Monsieur Vénus", "La Marquise de Sade"),
                               texte = c(demonAbsurde_v, monsieurVenus_v, marquiseSade_v))

str(tableau_synthese)

# Ajoutons un livre d'une autre auteure et d'un autre genre. Cela rendra l'exploration des données plus intéressantes. Nous allons importer un essai de l'écrivaine Louise Colet (1810-1876).

Colet_id <- ouvragesFrancais[grep(pattern = "Colet\\b", x=ouvragesFrancais$author),1]
ColetLivres <- gutenberg_download(Colet_id$gutenberg_id, mirror = mon_miroir, meta_fields = "title")
unique(ColetLivres$title)
str(ColetLivres)

# On voit que l'encodage doit du texte doit à nouveau être transformé
enfancesCelebres <- ColetLivres[, 2]
enfancesCelebres$text <- iconv(enfancesCelebres$text, from = "Latin1", to="UTF-8")
enfancesCelebres_v <- paste(enfancesCelebres$text, collapse = " ")

# Enchâssons le texte de Louise Colet dans une structure identique à celle de notre tableau synthèse
enfancesCelebres_df <- data.frame(auteur = "Louise Colet",
                                  titre = "Enfances célèbres",
                                  texte = enfancesCelebres_v)

str(enfancesCelebres_df)

# Et assemblons les deux tableaux avec la fonction de base `rbind` (pour "row bind" ==> coller les lignes)
tableau_synthese <- rbind(tableau_synthese, enfancesCelebres_df)

str(tableau_synthese)

# Nettoyage de l'environnement de travail.
rm(list=setdiff(ls(),c("tableau_synthese" )))

# La fonction `gc()` permet de nettoyer la mémoire.
gc()
```

## Manipulation des documents importés

Pour rendre la manipulation des données du tableau plus amusante, nous allons y ajouter quatre nouvelles colonnes. Trois d'entre elles contiendront des données numériques et la dernière sera de type catégoriel.

La première colonne à ajouter indiquera, pour chaque roman, le nombre de caractères (y compris le nombre d'espaces); la deuxième, le nombre de mots; la troisième, le nombre de phrases; la quatrième, le genre de l'ouvrage (roman/essai). Les données catégorielles demanderaient un développement en soit. Disons pour aller vite que ce sont des données qui se présentent au programmeur comme des chaînes de caractères, mais R les appréhende sous la forme de nombres entiers. On donne cette structure à la données lorsque sa variété est limitée et répétitive. La fonction utilisée pour créer un tel type de données est `factor()` et la transformation de chaînes de caractères en données catégorielles passe par la fonction `as.factor()`. On verra ci-dessous, une fois les données créées, l'implication de cette transformation.

Pour créer les trois premières colonnes, nous allons recourir l'extension `stringr` et à sa fonction `str_count()`. La même opération peut être faite en utilisant les fonctions de base de R (voir ci-dessous), mais comme il en faut pas moins de quatre pour arriver au même résultat, et qu'il faudrait avoir expliqué les structures de contrôle pour bien comprendre l'opération, nous allons prendre le raccourci appelé `stringr`!

La fonction `str_count()` fonctionne avec des motifs argument `pattern`) et nous allons donc pouvoir utiliser des expressions régulières pour calculer le nombre de caractères, le nombre de mots et le nombre de phrases.

Les expressions régulières utilisées sont les suivantes:
`.`                 ==>  tout(lettre, chiffre, ponctuation, espace), une seule fois;
`[:alpha:]`         ==>  toute lettre, une seule fois;
`+`                 ==>  quantifieur gourmand (attrape tout élément spécifié à sa gauche, jusqu'à ce qu'il rencontre autre chose);
`\\w`               ==>  caractère relevant d'un mot;
`[]`                ==>  le contenu des crochets, une seule fois.

```{r enrichissement-des-donnees}

library(stringr) # On réactive l'extension `stringr`, au cas où nous l'ayons pas fait déjà.

# Test expression régulière.

# test <- "Ceci est une phrase. Les mots que vous lisez forment une deuxième phrase. Pourquoi est-ce que nous écrivons ces mots? Pour pouvoir les compter, diantre!"

# str_count(test, "[[:alpha:]-]+")

tableau_synthese$nbre_car <- str_count(tableau_synthese$texte, pattern = ".")
tableau_synthese$nbre_mots <- str_count(tableau_synthese$texte, pattern = "[[:alpha:]-]+")
tableau_synthese$nbre_phrases <- str_count(tableau_synthese$texte, pattern = "\\w+[.?!]")

tableau_synthese$genre <- factor(c("nouvelles", "roman", "roman", "essai"))


# Équivalent en R-base (pour compter le nombre de caractères d'un vecteur):
# compter_motif_fun <- function(x=tableau_synthese$texte, y=".") {
#   sapply(regmatches(x, gregexpr(y, x)), length)
# }
# compter_motif_fun(x=test, y=".")
# str_count(test, pattern = ".")

str(tableau_synthese)
```

## Visualisation des résultats
Nous pouvons maintenant transposer le résultat dans une série de graphiques. R possède, dans l'extension de base, une fonction qui permet de faire facilement des graphiques (`plot()`), mais ceux-ci sont primaires. On recourt généralement à l'extension `ggplot2`, de la famille `tidyverse`, pour produire des graphiques plus complexes et attrayants.

Notre tableau est formé de variables catégorielles de type nominale (auteur, titre, genre) et de valeurs numériques de type discrètes (nbre_caracteres, etc.). On peut certes transposer des données catégorielles dans un graphique (à l'aide de couleurs, de tailles de caractères, etc.), mais il est plus aisé de composer avec des valeurs numériques.

Comme nous avons fait différents calculs à partir des textes, nous allons pouvoir composer un jeu de données qui les exclut, cela allègera d'autant la manipulation de la structure. On ne supprime pas la première structure, on la reproduit sans la volumineuse variable `texte`.
```{r visualisation}
library(reshape2)
library(ggplot2)

tableau_pour_graphique <- tableau_synthese[, -3] # Création d'un tableau pour graphique sans la variable `texte`

str(tableau_pour_graphique)

# Le premier graphique utilise le nombre de phrases sur l'axe y et donne à voir le nombre de mots (taille des points) et l'auteur (couleur)
ggplot(tableau_pour_graphique, aes(x = reorder(titre, nbre_phrases), 
                                   y = nbre_phrases, 
                                   size = nbre_mots, 
                                   color = auteur)) +
  geom_point(stat = "identity")+
  xlab("Titres")+
  ylab("Nombre de phrases")

# Pour utiliser un graphique à barres, il faut modifier la structure du tableau et ramener l'ensemble des valeurs numériques dans une seule colonne.
tableau_pour_graphique_barres <- melt(tableau_pour_graphique, id.vars=c("auteur", "titre", "genre"))

ggplot(tableau_pour_graphique_barres, aes(x=reorder(titre, value), y=value, fill= auteur))+
  geom_bar(stat="identity") +
  facet_wrap(~ variable,scales = "free_x") +
  xlab("Titres") +
  ylab("Valeurs") +
  coord_flip()

# Vous pouvez essayer de remplacer la valeur de "fill" avec les autres valeurs catégorielles (`titre`, `genre`)
```
# Suppléments à l'atelier

## Supplément 1: les listes

La liste ressemble au vecteur en ceci qu'il s'agit d'une structure de données unidimensionnelle, dont la longueur pourra être obtenue avec la fonction `length()`, mais, contrairement au vecteur, elle peut contenir tous types d'objets: des vecteurs de différents types, des fonctions, des listes, des tableaux de données, etc.

Créons une courte liste comprenant cinq vecteurs ayant chacun quatre éléments.

```{r}
mes_oeuvres_l <- list(nom = c("Anne Hébert",
                              "Nicole Brossard",
                              "Joséphine Bacon",
                              "Martine Delvaux"),
                      oeuvre = c("Le tombeau des rois",
                                 "Le désert mauve",
                                 "Un thé dans la toundra",
                                 "Les filles en série"),
                      annee = c(1953L, 1993L, 2013L, 2016L),
                      genre = c("poésie", "roman", "poésie", "essai"),
                      prose = c(FALSE, TRUE, FALSE, TRUE))

mes_oeuvres_l
```
La liste acceptant des éléments de différentes classes et types, la création de la nôtre n'a pas entraîné la transformation de ses éléments

```{r}
str(mes_oeuvres_l)
```

#### Indexation des éléments d'une liste par nom
En créant notre liste, on a attribué à chaque élément un nom avec l'opérateur `=`. On peut maintenant utiliser l'opérateur `$` pour appeler le contenu de l'élément. L'élément de la liste ainsi appelé sera un vecteur, ce qu'on peut vérifier en passant l'élément extrait à la fonction `str()`.

```{r extraction-liste-nom}
mes_oeuvres_l$nom

str(mes_oeuvres_l$nom)

```

#### Indexation des éléments d'une liste par position
L'indexation d'une liste peut également se faire en utilisant la position de l'élément (double crochets).

```{r extraction-liste-position-booleen}
mes_oeuvres_l[[1]] # Extraction du premier élément de la liste

```

On se souvient que notre liste est composée de quatre vecteurs. C'est donc dire que si on voulait manipuler le premier élément du premier vecteur composant notre liste, on pourrait le faire en suivant la logique `nom_liste``[[position_1er_element_liste]]``[position_1er_element_vecteur]`

```{r}
mes_oeuvres_l[[1]][1]

```

Si je souhaitais ajouter un élément à l'actuelle liste, je le ferais par assignation ou avec la fonction `append()`:

```{r}
mes_oeuvres_l$naissance_auteur <- c(1916L, 1943L, 1947L, 1968L)
mes_oeuvres_l <- append(mes_oeuvres_l, list(deces_auteur=c(2000, NA, NA, NA)))

```

L'ajout d'une valeur à la fin de chacun des éléments d'une liste est un peu plus compliqué, car ces éléments sont indépendants les uns des autres. C'est un peu comme si la liste était un train dont chaque élément constituait un wagon indépendant l'un de l'autre. Dès lors, la seule manière d'ajouter un élément à chacun des éléments de la liste est d'itérer sur chacun.

La fonction `mapply()` permet de faire une telle opération. Elle provient d'une famille de fonctions aussi rapide que puissante. Le premier argument de cette fonction... une fonction. On ajoute ensuite les arguments de la fonction convoquée, séparés par une virgule, puis on précise si on souhaite obtenir à la sortie un résultat « simplifié » (un vecteur) ou non. Dans le cas présent, nous souhaitons conserver la structure de la liste et nous allons donc donner la valeur FALSE à cet argument. 

```{r}
nouvel_auteur <- c("Elizabeth Bégon", "Lettres au cher fils", 1748L, "lettre", TRUE, 1696L, 1755L)

mes_oeuvres_l <- mapply(append, mes_oeuvres_l, nouvel_auteur, SIMPLIFY = FALSE)

mes_oeuvres_l
```


## Supplément 2 : l'extension `dplyr`

On a rapidement introduit l'extension `stringr` dans le dernier atelier. Cette extension fournit une multitude de fonctions permettant de manipuler les chaînes de caractères. 

Rappelons quelques-unes des fonctions de cette extension `stringr`:

* str_detect()            ==> Repère la présence d'un motif dans une chaîne (renvoit TRUE/FALSE)
* str_sub()               ==> Extraie un segment donné d'une chaîne de caractères (arguments: début = 1L, fin = 1L)
* str_subset()            ==> Extrait seulement les vecteurs contenant un certain motif
Etc.

La famille `tidyverse` fournit une autre extension, `dplyr`, qui offre une multitude de fonctions liées à la manipulation des tableaux, quelles que soient les valeurs de ce tableau.

* filter()                ==> Extrait des lignes répondant à certaines conditions particulières
* select()                ==> Sélectionne les colonnes et les réordonne au besoin
* pull()                  ==> Extrait les valeurs d'une colonne
* mutate()                ==> Crée une nouvelle colonne

![](data-transformation_Page_1.png)

L'extension `dplyr` et ses cousines de la famille `tidyverse` ont adopté l'utilisation généralisée de l'opérateur `%>%`, qui permet l'enchaînement des opérations. Il y a au moins trois avantages à utiliser cet opérateur: lisibilité (de gauche à droite), gain d'espace-mémoire (seul le résultat final de la chaîne d'opérations est assigné à une nouvelle variable) et rapidité d'exécution (le résultat d'une fonction est envoyé en entrée de la fonction suivante, et ainsi de suite).

Ajoutons deux nouvelles colonnes à notre tableau (`prenom` et `patronyme`), dont les valeurs proviendront d'une opération sur la colonne `nom`, éliminons ensuite cette colonne dont nous n'avons plus besoin, puis réordonnons l'ordre des colonnes.

```{r}
mes_oeuvres_df <- tibble(mes_oeuvres_df)

mes_oeuvres_df <- mes_oeuvres_df %>%
  mutate(., 
         prenom=str_extract(nom, pattern = "^[[:alpha:]]+"),
         patronyme=str_extract(nom, pattern = "(?<=\\s).+$")) %>%
  select(prenom, patronyme, initiales_auteur, oeuvre, annee, genre, prose)

mes_oeuvres_df

# Deux opérations en chaîne:
# 1. Création de deux nouvelles variables avec la fonction `dplyr::mutate()`;
# 2. On impose un nouvel ordre avec la fonction `dplyr::select()` et on en profite pour éliminer la variable `nom`, devenue inutile;

# Expressions régulières utilisées pour extraire les chaînes de caractères des deux nouvelles variables
# `¨` ==>`^`          ==>  au début de l'élément
# `[[:alpha:]]+`      ==>  toute lettre jusqu'à ce qu'un autre type de caractère soit trouvé (soit l'espace séparant le prénom et le patronyme)
# (?<=\\s).+$         ==>  tout caractère précédé d'une espace, et cela jusqu'à la fin de la chaîne de caractère. Note: le groupe (?<=\\s) n'attrape pas l'espace.

```
